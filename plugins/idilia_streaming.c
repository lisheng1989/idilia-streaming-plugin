/*! \file   janus_streaming.c
 * \author Lorenzo Miniero <lorenzo@meetecho.com>
 * \copyright GNU General Public License v3
 * \brief  Janus Streaming plugin
 * \details  This is a streaming plugin for Janus, allowing WebRTC peers
 * to watch/listen to pre-recorded files or media generated by another tool.
 * Specifically, the plugin currently supports three different type of streams:
 * 
 * -# on-demand streaming of pre-recorded media files (different
 * streaming context for each peer);
 * -# live streaming of pre-recorded media files (shared streaming
 * context for all peers attached to the stream);
 * -# live streaming of media generated by another tool (shared
 * streaming context for all peers attached to the stream).
 * 
 * For what concerns types 1. and 2., considering the proof of concept
 * nature of the implementation the only pre-recorded media files
 * that the plugins supports right now are raw mu-Law and a-Law files:
 * support is of course planned for other additional widespread formats
 * as well.
 * 
 * For what concerns type 3., instead, the plugin is configured
 * to listen on a couple of ports for RTP: this means that the plugin
 * is implemented to receive RTP on those ports and relay them to all
 * peers attached to that stream. Any tool that can generate audio/video
 * RTP streams and specify a destination is good for the purpose: the
 * examples section contains samples that make use of GStreamer (http://gstreamer.freedesktop.org/)
 * but other tools like FFmpeg (http://www.ffmpeg.org/), LibAV (http://libav.org/)
 * or others are fine as well. This makes it really easy to capture and
 * encode whatever you want using your favourite tool, and then have it
 * transparently broadcasted via WebRTC using Janus.
 * 
 * Streams to make available are listed in the plugin configuration file.
 * A pre-filled configuration file is provided in \c conf/janus.plugin.streaming.cfg
 * and includes a stream of every type.
 * 
 * To add more streams or modify the existing ones, you can use the following
 * syntax:
 * 
 * \verbatim
[stream-name]
type = rtp|live|ondemand|rtsp
       rtp = stream originated by an external tool (e.g., gstreamer or
             ffmpeg) and sent to the plugin via RTP
       live = local file streamed live to multiple listeners
              (multiple listeners = same streaming context)
       ondemand = local file streamed on-demand to a single listener
                  (multiple listeners = different streaming contexts)
       rtsp = stream originated by an external RTSP feed (only
              available if libcurl support was compiled)
id = <unique numeric ID>
description = This is my awesome stream
is_private = yes|no (private streams don't appear when you do a 'list' request)
filename = path to the local file to stream (only for live/ondemand)
secret = <optional password needed for manipulating (e.g., destroying
		or enabling/disabling) the stream>
pin = <optional password needed for watching the stream>
audio = yes|no (do/don't stream audio)
video = yes|no (do/don't stream video)
   The following options are only valid for the 'rtp' type:
audioport = local port for receiving audio frames
audiomcast = multicast group port for receiving audio frames, if any
audiopt = <audio RTP payload type> (e.g., 111)
audiortpmap = RTP map of the audio codec (e.g., opus/48000/2)
audiofmtp = Codec specific parameters, if any
videoport = local port for receiving video frames (only for rtp)
videomcast = multicast group port for receiving video frames, if any
videopt = <video RTP payload type> (e.g., 100)
videortpmap = RTP map of the video codec (e.g., VP8/90000)
videofmtp = Codec specific parameters, if any

   The following options are only valid for the 'rstp' type:
url = RTSP stream URL (only if type=rtsp)
\endverbatim
 *
 * \section streamapi Streaming API
 * 
 * The Streaming API supports several requests, some of which are
 * synchronous and some asynchronous. There are some situations, though,
 * (invalid JSON, invalid request) which will always result in a
 * synchronous error response even for asynchronous requests. 
 * 
 * \c list , \c create , \c destroy , \c recording , \c enable and
 * \c disable are synchronous requests, which means you'll
 * get a response directly within the context of the transaction. \c list
 * lists all the available streams; \c create allows you to create a new
 * mountpoint dynamically, as an alternative to using the configuration
 * file; \c destroy removes a mountpoint and destroys it; \c recording
 * instructs the plugin on whether or not a live RTP stream should be
 * recorded while it's broadcasted; \c enable and \c disable respectively
 * enable and disable a mountpoint, that is decide whether or not a
 * mountpoint should be available to users without destroying it.
 * 
 * The \c watch , \c start , \c pause , \c switch and \c stop requests
 * instead are all asynchronous, which means you'll get a notification
 * about their success or failure in an event. \c watch asks the plugin
 * to prepare the playout of one of the available streams; \c start
 * starts the actual playout; \c pause allows you to pause a playout
 * without tearing down the PeerConnection; \c switch allows you to
 * switch to a different mountpoint of the same kind (note: only live
 * RTP mountpoints supported as of now) without having to stop and watch
 * the new one; \c stop stops the playout and tears the PeerConnection
 * down.
 * 
 * Notice that, in general, all users can create mountpoints, no matter
 * what type they are. If you want to limit this functionality, you can
 * configure an admin \c admin_key in the plugin settings. When
 * configured, only "create" requests that include the correct
 * \c admin_key value in an "admin_key" property will succeed, and will
 * be rejected otherwise.
 * 
 * Actual API docs: TBD.
 * 
 * \ingroup plugins
 * \ref plugins
 */

#include "plugin.h"

#include <jansson.h>
#include <errno.h>
#include <sys/poll.h>
#include <sys/time.h>

#ifdef HAVE_LIBCURL
#include <curl/curl.h>
#endif

#include "../debug.h"
#include "../apierror.h"
#include "../config.h"
#include "../mutex.h"
#include "../rtp.h"
#include "../rtcp.h"
#include "../record.h"
#include "../utils.h"
#include "idilia_streaming_common.h"
#include "idilia_streaming.h"
#include "socket_utils.h"
#include "gst_utils.h"
#include "ports_pool.h"
#include "curl_utils.h"
#include <gst/gst.h>
#include <gst/sdp/gstsdpmessage.h>  
#include <gst/rtsp/rtsp.h>


/* Plugin information */
#define JANUS_STREAMING_VERSION			6
#define JANUS_STREAMING_VERSION_STRING	"0.0.6"
#define JANUS_STREAMING_DESCRIPTION		"This is a streaming plugin for Janus, allowing WebRTC peers to watch/listen to pre-recorded files or media generated by gstreamer."
#define JANUS_STREAMING_NAME			"JANUS Streaming plugin"
#define JANUS_STREAMING_AUTHOR			"Meetecho s.r.l."
#define JANUS_STREAMING_PACKAGE			"idilia.plugin.streaming"

/* Plugin methods */
janus_plugin *create(void);
int janus_streaming_init(janus_callbacks *callback, const char *config_path);
void janus_streaming_destroy(void);
int janus_streaming_get_api_compatibility(void);
int janus_streaming_get_version(void);
const char *janus_streaming_get_version_string(void);
const char *janus_streaming_get_description(void);
const char *janus_streaming_get_name(void);
const char *janus_streaming_get_author(void);
const char *janus_streaming_get_package(void);
void janus_streaming_create_session(janus_plugin_session *handle, int *error);
struct janus_plugin_result *janus_streaming_handle_message(janus_plugin_session *handle, char *transaction, json_t *message, json_t *jsep);
void janus_streaming_setup_media(janus_plugin_session *handle);
void janus_streaming_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len);
void janus_streaming_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len);
void janus_streaming_hangup_media(janus_plugin_session *handle);
void janus_streaming_destroy_session(janus_plugin_session *handle, int *error);
json_t *janus_streaming_query_session(janus_plugin_session *handle);

/* Plugin setup */
static janus_plugin janus_streaming_plugin =
	JANUS_PLUGIN_INIT (
		.init = janus_streaming_init,
		.destroy = janus_streaming_destroy,

		.get_api_compatibility = janus_streaming_get_api_compatibility,
		.get_version = janus_streaming_get_version,
		.get_version_string = janus_streaming_get_version_string,
		.get_description = janus_streaming_get_description,
		.get_name = janus_streaming_get_name,
		.get_author = janus_streaming_get_author,
		.get_package = janus_streaming_get_package,
		
		.create_session = janus_streaming_create_session,
		.handle_message = janus_streaming_handle_message,
		.setup_media = janus_streaming_setup_media,
		.incoming_rtp = janus_streaming_incoming_rtp,
		.incoming_rtcp = janus_streaming_incoming_rtcp,
		.hangup_media = janus_streaming_hangup_media,
		.destroy_session = janus_streaming_destroy_session,
		.query_session = janus_streaming_query_session,
	);

/* Plugin creator */
janus_plugin *create(void) {
	JANUS_LOG(LOG_VERB, "%s created!\n", JANUS_STREAMING_NAME);
	return &janus_streaming_plugin;
}

/* Parameter validation */
static struct janus_json_parameter request_parameters[] = {
	{"request", JSON_STRING, JANUS_JSON_PARAM_REQUIRED}
};
static struct janus_json_parameter id_parameters[] = {
	{"id", JSON_STRING, JANUS_JSON_PARAM_REQUIRED | JANUS_JSON_PARAM_NONEMPTY}
};
static struct janus_json_parameter adminkey_parameters[] = {
	{"admin_key", JSON_STRING, JANUS_JSON_PARAM_REQUIRED}
};
static struct janus_json_parameter create_parameters[] = {
	{"type", JSON_STRING, JANUS_JSON_PARAM_REQUIRED},
	{"secret", JSON_STRING, 0},
	{"pin", JSON_STRING, 0},
	{"permanent", JANUS_JSON_BOOL, 0}
};

/* Static configuration instance */
static janus_config *config = NULL;
static const char *config_folder = NULL;
static janus_mutex config_mutex;

/* Useful stuff */
static volatile gint initialized = 0, stopping = 0;
static janus_callbacks *gateway = NULL;
static GThread *handler_thread;
static GThread *watchdog;
static void *janus_streaming_handler(void *data);

#define JANUS_STREAMING_VP8		0
#define JANUS_STREAMING_H264	1
#define JANUS_STREAMING_VP9		2

GHashTable *mountpoints;
static GList *old_mountpoints;
janus_mutex mountpoints_mutex;
static char *admin_key = NULL;


/* configuration options */
static uint16_t udp_min_port = 0, udp_max_port = 0;
static guint latency = 0;

typedef struct janus_streaming_message {
	janus_plugin_session *handle;
	char *transaction;
	json_t *message;
	json_t *jsep;
} janus_streaming_message;
static GAsyncQueue *messages = NULL;
static janus_streaming_message exit_message;


typedef struct janus_streaming_session {
	janus_plugin_session *handle;
	janus_streaming_mountpoint *mountpoint;
	gboolean started;
	gboolean paused;
	gboolean stopping;
	volatile gint hangingup;
	gint64 destroyed;	/* Time at which this session was marked as destroyed */
} janus_streaming_session;
static GHashTable *sessions;
static GList *old_sessions;
static janus_mutex sessions_mutex;

/* Packets we get from gstreamer and relay */
typedef struct janus_streaming_rtp_relay_packet {
	rtp_header *data;
	gint length;
	gint is_video;
	uint32_t timestamp;
	uint16_t seq_number;
} janus_streaming_rtp_relay_packet;


/* function declarations */
static void janus_streaming_mountpoint_free(gpointer data);
janus_streaming_mountpoint *janus_streaming_create_rtp_source(
		janus_plugin_session *handle,
		const gchar *id, char *name, char *desc);
static void janus_streaming_parse_ports_range(janus_config_item *ports_range, uint16_t * udp_min_port, uint16_t * udp_max_port);
static gboolean janus_streaming_create_sockets(socket_utils_socket socket[JANUS_STREAMING_STREAM_MAX][JANUS_STREAMING_SOCKET_MAX]);
gboolean janus_streaming_send_rtp_src_received(GSocket *socket, GIOCondition condition, janus_streaming_socket_cbk_data * data);
static void janus_streaming_relay_rtp_packet(gpointer data, gpointer user_data);
static void janus_streaming_destroy_mountpoint(gchar *id_value);
static void janus_streaming_destroy_mountpoint_if_not_used(janus_streaming_session *session);


static void
print_hash_value (gpointer key, gpointer val, gpointer data)
{
   printf ("%u -> %u\n", key, val);
}

/* Error codes */
#define JANUS_STREAMING_ERROR_NO_MESSAGE			450
#define JANUS_STREAMING_ERROR_INVALID_JSON			451
#define JANUS_STREAMING_ERROR_INVALID_REQUEST		452
#define JANUS_STREAMING_ERROR_MISSING_ELEMENT		453
#define JANUS_STREAMING_ERROR_INVALID_ELEMENT		454
#define JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT	455
#define JANUS_STREAMING_ERROR_CANT_CREATE			456
#define JANUS_STREAMING_ERROR_UNAUTHORIZED			457
#define JANUS_STREAMING_ERROR_CANT_SWITCH			458
#define JANUS_STREAMING_ERROR_UNKNOWN_ERROR			470

static const gchar *janus_endpoint = NULL;
static const gchar *registry_endpoint = NULL;

static GHashTable *transcode_threads = NULL;
static GHashTable *transcode_main_loops = NULL;


janus_mutex transcode_threads_mutex;
janus_mutex transcode_main_loops_mutex;




static void janus_streaming_message_free(janus_streaming_message *msg) {
	if(!msg || msg == &exit_message)
		return;

	msg->handle = NULL;

	g_free(msg->transaction);
	msg->transaction = NULL;
	if(msg->message)
		json_decref(msg->message);
	msg->message = NULL;
	if(msg->jsep)
		json_decref(msg->jsep);
	msg->jsep = NULL;

	g_free(msg);
}

static void g_str_destroy(gpointer data) {
	g_free(data);
}

static gchar *random_text(guint len, const gchar *char_set) {

	gchar *random_str = g_new0(gchar, len + 1);
	guint i = 0;

	for (i = 0; i < len; i++) {
		random_str[i] = char_set[g_random_int_range(0, strlen(char_set))];
	}

	return random_str;

}


static gchar *random_id(void) {

	return random_text(32, "abcdefghijklmnopqrstuvwxyz0123456789");

}

static void teardown_pipeline(janus_streaming_mountpoint *mountpoint) {

	JANUS_LOG(LOG_INFO, "teardown_pipeline\n");

	if (!mountpoint) {
		JANUS_LOG(LOG_ERR, "Input parameter mountpoint was null.\n");
		return;
	}

	janus_mutex_lock(&transcode_main_loops_mutex);
	GMainLoop *main_loop = g_hash_table_lookup(transcode_main_loops,mountpoint->id);
	if (main_loop != NULL) {
		g_hash_table_remove(transcode_main_loops, mountpoint->id);
		if (g_main_loop_is_running (main_loop)) {
			JANUS_LOG(LOG_INFO, "\n main_loop_quit \n");		
			g_main_loop_quit(main_loop);
		}
		g_main_loop_unref(main_loop);
		main_loop = NULL; 
	}
	janus_mutex_unlock(&transcode_main_loops_mutex);

	janus_mutex_lock(&transcode_threads_mutex);
	GThread * thread = g_hash_table_lookup(transcode_threads, mountpoint->id);
	if(thread){
		JANUS_LOG(LOG_INFO, "\nThread join\n");		
		g_hash_table_remove(transcode_threads, mountpoint->id);					
		g_thread_join(thread);
		thread = NULL;								
	}
	janus_mutex_unlock(&transcode_threads_mutex);

	JANUS_LOG(LOG_INFO, "Close sockets\n");	
	for (int stream = 0; stream < JANUS_STREAMING_STREAM_MAX; stream++) {
		for (int j = 0; j < JANUS_STREAMING_SOCKET_MAX; j++) {
			socket_utils_close_socket(&mountpoint->socket[stream][j]);
		}
	}

	JANUS_LOG(LOG_INFO, "teardown_pipeline end\n");
}

static gpointer transcode_handler(gpointer data) {

	GstElement *pipeline = NULL;	
	GstBus *bus = NULL;
	GSource *bus_source = NULL;
	GMainContext *context = NULL;
	GMainLoop *main_loop = NULL;

	pipeline_data_t *pipeline_data = (pipeline_data_t *)data;

	JANUS_LOG(LOG_INFO, "Enter transcode_handler\n");

	do
	{
		if (!pipeline_data) {
			JANUS_LOG(LOG_ERR, "Input parameter data is null.\n");
			break;
		}

		if (!pipeline_data->uri) {
			JANUS_LOG(LOG_ERR, "Invalid format of uri\n");
			break;
		}
		janus_mutex_lock(&mountpoints_mutex);
		janus_streaming_mountpoint *mountpoint = g_hash_table_lookup(mountpoints, pipeline_data->id);
		janus_mutex_unlock(&mountpoints_mutex);

		if (!mountpoint) {
			JANUS_LOG(LOG_ERR, "Invalid mountpoint ptr\n");
			break;
		}

		memset(mountpoint->socket, 0, sizeof(mountpoint->socket));

		if (!janus_streaming_create_sockets(mountpoint->socket))
		{
			JANUS_LOG(LOG_FATAL, "Unable to create one or more sockets!\n");
			break;
		}

		GstElement *sender_bin, *source = NULL;
		pipeline_callback_t callback_data;

		/* create a new pipeline to hold the elements */
		pipeline = gst_pipeline_new ("pipeline");
		g_assert (pipeline);

		sender_bin = sender_bin_create();
		g_assert (sender_bin);
    	gst_bin_add_many (GST_BIN (pipeline), sender_bin, NULL);

		callback_data.pipeline = pipeline;
		callback_data.mountpoint = mountpoint;
		callback_data.uri = pipeline_data->uri;
		callback_data.handle = pipeline_data->handle;

		if (g_str_has_prefix (pipeline_data->uri, "rtsp://")) {
			source = create_rtsp_source_element(&callback_data, pipeline_data);
			gst_bin_add_many (GST_BIN (pipeline), source, NULL);
		} else if (g_str_has_prefix (pipeline_data->uri, "videotestsrc://")) { 
			source = create_videotestsrc_bin(pipeline, pipeline_data);
			GstElement * output_bin = create_remote_rtp_output(
				mountpoint->socket[JANUS_STREAMING_STREAM_VIDEO][JANUS_STREAMING_SOCKET_RTP_SRV].port, 
				"video");
			gst_bin_add_many (GST_BIN (pipeline), source, output_bin, NULL);
			gst_element_link_many (source, sender_bin, output_bin, NULL);
		} else {
			JANUS_LOG(LOG_ERR, "Unsupported source protocol!\n");
			break;
		}

		/* Attach RTP callback */
		for (int stream = 0; stream < JANUS_STREAMING_STREAM_MAX; stream++)
		{
			mountpoint->rtp_cbk_data[stream].session = (gpointer)mountpoint;
			mountpoint->rtp_cbk_data[stream].is_video = (stream == JANUS_STREAMING_STREAM_VIDEO);

			socket_utils_attach_callback(&mountpoint->socket[stream][JANUS_STREAMING_SOCKET_RTP_SRV],
				(GSourceFunc)janus_streaming_send_rtp_src_received,
				(gpointer)&mountpoint->rtp_cbk_data[stream]);
		}

		if (GST_STATE_CHANGE_FAILURE == gst_element_set_state(pipeline, GST_STATE_PLAYING)) {
			JANUS_LOG(LOG_ERR, "Could not change state of pipeline to PLAYING state.\n");
			break;
		}

		GstState state;
		GstStateChangeReturn ret;
	//todo: cleanup
#if 0
		do
		{
			if (GST_STATE_CHANGE_FAILURE == (ret = gst_element_get_state(pipeline,
				&state, NULL, GST_CLOCK_TIME_NONE))) {
				JANUS_LOG(LOG_ERR, "Could not change state of pipeline to PLAYING state.\n");
				break;
			}
		}
		while (GST_STATE_PLAYING != state);
		if (GST_STATE_CHANGE_FAILURE == ret) {
			break;
		}
#endif
		if (NULL == (bus = gst_element_get_bus (pipeline))) {
			JANUS_LOG(LOG_ERR, "Could not get the bus.\n");
			break;
		}
		if (NULL == (bus_source = gst_bus_create_watch(bus))) {
			JANUS_LOG(LOG_ERR, "Could not create a watch.\n");
			break;
		}


		if (NULL == (context = g_main_context_new())) {
			JANUS_LOG(LOG_ERR, "Could not create new context.\n");
			break;
		}
		g_main_context_push_thread_default(context);
		g_source_set_callback(bus_source, (GSourceFunc) gst_bus_async_signal_func, NULL, NULL);
		g_source_attach(bus_source, context);
		g_source_unref(bus_source);
		bus_source = NULL;
		janus_mutex_lock(&transcode_main_loops_mutex);
		main_loop = g_main_loop_new(context, FALSE);
		g_signal_connect (G_OBJECT (bus), "message::eos", (GCallback)on_eos, &callback_data);
		g_signal_connect (G_OBJECT (bus), "message::error", (GCallback)on_error, &callback_data);
		gst_object_unref(bus);
		bus = NULL;
		g_hash_table_insert(transcode_main_loops, pipeline_data->id, main_loop);
		janus_mutex_unlock(&transcode_main_loops_mutex);		
		g_free(pipeline_data);
		pipeline_data = NULL;

#if 0
		sleep(10);
    	GST_DEBUG_BIN_TO_DOT_FILE(GST_BIN(pipeline), GST_DEBUG_GRAPH_SHOW_ALL, "pipeline_delayed");
#endif

		g_main_loop_run(main_loop);
		if (GST_STATE_CHANGE_FAILURE == gst_element_set_state(pipeline, GST_STATE_NULL)) {
			JANUS_LOG(LOG_ERR, "Could not change state of pipeline to NULL state.\n");
		}
		else { 
			do
			{
				if (GST_STATE_CHANGE_FAILURE == (ret = gst_element_get_state(pipeline,
					&state, NULL, GST_CLOCK_TIME_NONE))) {
					JANUS_LOG(LOG_ERR, "Could not change state of pipeline to NULL state.\n");
					break;
				}
			}
			while (GST_STATE_NULL != state);
		}

		gst_object_unref(GST_OBJECT(pipeline));
		pipeline = NULL;
		g_main_context_pop_thread_default(context);
		g_main_context_unref(context);
		context = NULL;
	}
	while(0);

	// cleanup
	if (bus_source) {
		g_source_unref(bus_source);
		bus_source = NULL;
	}
	if (bus) {
		gst_object_unref(bus);
		bus = NULL;
	}

	if (context) {
		g_main_context_unref(context);
		context = NULL;
	}

	if (pipeline) {
		gst_object_unref(pipeline);
		pipeline = NULL;
	}
	if (pipeline_data) {
		if (pipeline_data->uri) {
			g_free(pipeline_data->uri);
			pipeline_data->uri = NULL;
		}
		g_free(pipeline_data);
		pipeline_data = NULL;
	}

	JANUS_LOG(LOG_INFO, "Exit transcode_handler\n");

	return NULL;
}

static void setup_pipeline(janus_plugin_session * handle,const gchar* source, const gchar *id) {

	do {	
		if(source){
			// allocation - deallocated within the thread
			pipeline_data_t *pipeline_data = g_malloc0(sizeof(pipeline_data_t));
			if (!pipeline_data) {
				JANUS_LOG(LOG_ERR, "Could not allocate pipeline data.\n");
				break;
			}
			// allocation - deallocated when removing form the transcode_main_loops hash table
			pipeline_data->id = g_strdup(id);
			// allocation - deallocated within the thread

			pipeline_data->uri = g_strdup(source);
			pipeline_data->latency = latency;
			pipeline_data->handle = handle;
			
			GError *error = NULL;
			// allocation
			GThread *thread_handler = g_thread_try_new("transcode handler", transcode_handler, pipeline_data, &error);
			if (!thread_handler) {
				if (error) {
					JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the transcode handler thread...\n", error->code,
							error->message ? error->message : "??");
				} else {
					JANUS_LOG(LOG_ERR, "Failed to start transcode handler...\n");
				}
				g_free(pipeline_data->id);
				pipeline_data->id = NULL;
				g_free(pipeline_data->uri);
				pipeline_data->uri = NULL;
				g_free(pipeline_data);
				pipeline_data = NULL;
				break;
			}
			janus_mutex_lock(&transcode_threads_mutex);
			g_hash_table_insert(transcode_threads, (gchar *)id, thread_handler);
			janus_mutex_unlock(&transcode_threads_mutex);

		}

	}
	while(0);

}

/* Streaming watchdog/garbage collector (sort of) */
void *janus_streaming_watchdog(void *data);
void *janus_streaming_watchdog(void *data) {
	JANUS_LOG(LOG_INFO, "Streaming watchdog started\n");
	gint64 now = 0;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		janus_mutex_lock(&sessions_mutex);
		/* Iterate on all the sessions */
		now = janus_get_monotonic_time();
		if(old_sessions != NULL) {
			GList *sl = old_sessions;
			JANUS_LOG(LOG_HUGE, "Checking %d old Streaming sessions...\n", g_list_length(old_sessions));
			while(sl) {
				janus_streaming_session *session = (janus_streaming_session *)sl->data;
				if(!session) {
					sl = sl->next;
					continue;
				}
				if(now-session->destroyed >= 5*G_USEC_PER_SEC) {
					/* We're lazy and actually get rid of the stuff only after a few seconds */
					JANUS_LOG(LOG_VERB, "Freeing old Streaming session\n");
					GList *rm = sl->next;
					old_sessions = g_list_delete_link(old_sessions, sl);
					sl = rm;
					session->handle = NULL;
					g_free(session);
					session = NULL;
					continue;
				}
				sl = sl->next;
			}
		}
		janus_mutex_unlock(&sessions_mutex);
		janus_mutex_lock(&mountpoints_mutex);
		/* Iterate on all the mountpoints */
		if(old_mountpoints != NULL) {
			GList *sl = old_mountpoints;
			JANUS_LOG(LOG_HUGE, "Checking %d old Streaming mountpoints...\n", g_list_length(old_mountpoints));
			while(sl) {
				janus_streaming_mountpoint *mountpoint = (janus_streaming_mountpoint *)sl->data;
				if(!mountpoint) {
					sl = sl->next;
					continue;
				}
				if(now-mountpoint->destroyed >= 5*G_USEC_PER_SEC) {
					/* We're lazy and actually get rid of the stuff only after a few seconds */
					JANUS_LOG(LOG_VERB, "Freeing old Streaming mountpoint\n");
					GList *rm = sl->next;
					old_mountpoints = g_list_delete_link(old_mountpoints, sl);
					sl = rm;
					mountpoint = NULL;
					continue;
				}
				sl = sl->next;
			}
		}
		janus_mutex_unlock(&mountpoints_mutex);
		g_usleep(500000);
	}
	JANUS_LOG(LOG_INFO, "Streaming watchdog stopped\n");
	return NULL;
}


/* Plugin implementation */
int janus_streaming_init(janus_callbacks *callback, const char *config_path) {
	GstDebugLevel level = GST_LEVEL_NONE;
	gst_init(NULL, NULL);	
	switch(janus_log_level) {
		case LOG_FATAL:
		case LOG_ERR:
			level = GST_LEVEL_ERROR;
			break;
		case LOG_WARN:
		case LOG_INFO:
			level = GST_LEVEL_WARNING;
			break;
		case LOG_VERB:
			level = GST_LEVEL_INFO;
			break;
		case LOG_HUGE:
			level = GST_LEVEL_DEBUG;
			break;
		case LOG_DBG:
			level = GST_LEVEL_TRACE;
			break;
		default:
			level = GST_LEVEL_NONE;
	}
	gst_debug_set_default_threshold(level);
	gst_debug_set_threshold_from_string("*:3,udpsrc:3,*CAPS*:3,rtpsession:3,GST_EVENT*:3", TRUE);
#ifdef HAVE_LIBCURL	
	curl_global_init(CURL_GLOBAL_ALL);
#endif	
	if(g_atomic_int_get(&stopping)) {
		/* Still stopping from before */
		return -1;
	}
	if(callback == NULL || config_path == NULL) {
		/* Invalid arguments */
		return -1;
	}

	/* Read configuration */
	char filename[255];
	g_snprintf(filename, 255, "%s/%s.cfg", config_path, JANUS_STREAMING_PACKAGE);
	JANUS_LOG(LOG_VERB, "Configuration file: %s\n", filename);
	config = janus_config_parse(filename);
	config_folder = config_path;
	if(config != NULL)
		janus_config_print(config);
	janus_mutex_init(&config_mutex);
	
	mountpoints = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, janus_streaming_mountpoint_free);
	transcode_threads = g_hash_table_new(g_str_hash, g_str_equal);
	transcode_main_loops = g_hash_table_new_full(g_str_hash, g_str_equal, g_str_destroy, NULL);
	
	janus_mutex_init(&mountpoints_mutex);
	janus_mutex_init(&transcode_threads_mutex);
	janus_mutex_init(&transcode_main_loops_mutex);
	

	/* Parse configuration to populate the mountpoints */
	if(config != NULL) {
		janus_config_item *item;

		janus_streaming_parse_ports_range(janus_config_get_item_drilldown(config, "general", "rtp_port_range"), &udp_min_port, &udp_max_port);

		if (udp_min_port <= 0 || udp_max_port <= 0) {
			udp_min_port = 40001;
			udp_max_port = 50000;
			JANUS_LOG(LOG_WARN, "Using default port range: %d-%d\n", udp_min_port, udp_max_port);
		}

		item = janus_config_get_item_drilldown(config, "general", "janus_endpoint");
		if (item && item->value) {
			janus_endpoint = item->value;
		}
		else {
			janus_endpoint = "http://localhost:8088/janus";
		}
		item = janus_config_get_item_drilldown(config, "general", "registry_endpoint");
		if (item && item->value) {
			registry_endpoint = item->value;
		}
		item = janus_config_get_item_drilldown(config, "general", "latency");
		if (item && item->value) {
			latency = atoi(item->value);
		}
		else {
			latency = 200;
		} 
	
	}		

	socket_utils_init(udp_min_port, udp_max_port);

	sessions = g_hash_table_new(NULL, NULL);
	janus_mutex_init(&sessions_mutex);
	messages = g_async_queue_new_full((GDestroyNotify) janus_streaming_message_free);
	/* This is the callback we'll need to invoke to contact the gateway */
	gateway = callback;
	g_atomic_int_set(&initialized, 1);

	GError *error = NULL;
	/* Start the sessions watchdog */
	watchdog = g_thread_try_new("streaming watchdog", &janus_streaming_watchdog, NULL, &error);
	if(!watchdog) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the Streaming watchdog thread...\n", error->code, error->message ? error->message : "??");
		janus_config_destroy(config);
		return -1;
	}
	/* Launch the thread that will handle incoming messages */
	handler_thread = g_thread_try_new("streaming handler", janus_streaming_handler, NULL, &error);
	if(error != NULL) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the Streaming handler thread...\n", error->code, error->message ? error->message : "??");
		janus_config_destroy(config);
		return -1;
	}
	JANUS_LOG(LOG_INFO, "%s initialized!\n", JANUS_STREAMING_NAME);
	return 0;
}

void janus_streaming_destroy(void) {
	if(!g_atomic_int_get(&initialized))
		return;
	g_atomic_int_set(&stopping, 1);

	g_async_queue_push(messages, &exit_message);

	//if(handler_thread != NULL) {
	//	g_thread_join(handler_thread);
	//	handler_thread = NULL;
	//}

	/* Remove all mountpoints */
	janus_mutex_lock(&mountpoints_mutex);
	GHashTableIter iter;
	gpointer value;
	g_hash_table_iter_init(&iter, mountpoints);
	while (g_hash_table_iter_next(&iter, NULL, &value)) {
		janus_streaming_mountpoint *mp = value;
		if(!mp->destroyed) {
			mp->destroyed = janus_get_monotonic_time();
			old_mountpoints = g_list_append(old_mountpoints, mp);
		}
	}
	janus_mutex_unlock(&mountpoints_mutex);
	janus_mutex_lock(&transcode_main_loops_mutex);
	g_hash_table_iter_init(&iter, transcode_main_loops);
	while (g_hash_table_iter_next(&iter, NULL, &value)) {
		g_main_loop_quit(value);
	}
	g_hash_table_remove_all(transcode_main_loops);
	g_hash_table_destroy(transcode_main_loops);	
	transcode_main_loops = NULL;
	janus_mutex_unlock(&transcode_main_loops_mutex);
	janus_mutex_lock(&transcode_threads_mutex);	
	g_hash_table_iter_init(&iter, transcode_threads);	
	while (g_hash_table_iter_next(&iter, NULL, &value)) {
		g_thread_join(value);
	}
	g_hash_table_remove_all(transcode_threads);
	g_hash_table_destroy(transcode_threads);
	transcode_threads = NULL;
	janus_mutex_unlock(&transcode_threads_mutex);
	
	socket_utils_destroy();
	
	if(watchdog != NULL) {
		g_thread_join(watchdog);
		watchdog = NULL;
	}

	/* FIXME We should destroy the sessions cleanly */
	usleep(500000);
	janus_mutex_lock(&mountpoints_mutex);
	g_hash_table_destroy(mountpoints);
	janus_mutex_unlock(&mountpoints_mutex);
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_destroy(sessions);
	janus_mutex_unlock(&sessions_mutex);
	g_async_queue_unref(messages);
	messages = NULL;
	sessions = NULL;

	janus_config_destroy(config);
	g_free(admin_key);

	g_atomic_int_set(&initialized, 0);
	g_atomic_int_set(&stopping, 0);
	JANUS_LOG(LOG_INFO, "%s destroyed!\n", JANUS_STREAMING_NAME);
}

int janus_streaming_get_api_compatibility(void) {
	/* Important! This is what your plugin MUST always return: don't lie here or bad things will happen */
	return JANUS_PLUGIN_API_VERSION;
}

int janus_streaming_get_version(void) {
	return JANUS_STREAMING_VERSION;
}

const char *janus_streaming_get_version_string(void) {
	return JANUS_STREAMING_VERSION_STRING;
}

const char *janus_streaming_get_description(void) {
	return JANUS_STREAMING_DESCRIPTION;
}

const char *janus_streaming_get_name(void) {
	return JANUS_STREAMING_NAME;
}

const char *janus_streaming_get_author(void) {
	return JANUS_STREAMING_AUTHOR;
}

const char *janus_streaming_get_package(void) {
	return JANUS_STREAMING_PACKAGE;
}

void janus_streaming_create_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}	

	JANUS_LOG(LOG_INFO, "janus_streaming_create_session\n");

	janus_streaming_session *session = (janus_streaming_session *)g_malloc0(sizeof(janus_streaming_session));

	session->handle = handle;
	session->mountpoint = NULL;	/* This will happen later */
	session->started = FALSE;	/* This will happen later */
	session->paused = FALSE;
	session->destroyed = 0;
	g_atomic_int_set(&session->hangingup, 0);
	handle->plugin_handle = session;
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_insert(sessions, handle, session);
	janus_mutex_unlock(&sessions_mutex);

	return;
}


static void janus_streaming_destroy_mountpoint(gchar *id_value)
{
	janus_mutex_lock(&mountpoints_mutex);
	janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);

	if (mp == NULL) {
		janus_mutex_unlock(&mountpoints_mutex);			
		JANUS_LOG(LOG_ERR, "No such mountpoint/stream %s ", id_value);
		return;
	}

	JANUS_LOG(LOG_INFO, "Request to unmount mountpoint/stream %s\n", id_value);
	/* FIXME Should we kick the current viewers as well? */
	janus_mutex_lock(&mp->mutex);
	GList *viewer = g_list_first(mp->listeners);

	/* Prepare JSON event */
	json_t *event = json_object();
	json_object_set_new(event, "streaming", json_string("event"));
	json_t *result = json_object();
	json_object_set_new(result, "status", json_string("stopped"));
	json_object_set_new(event, "result", result);

	while (viewer) {
		janus_streaming_session *session = (janus_streaming_session *)viewer->data;
		if(session != NULL) {
			session->stopping = TRUE;
			session->started = FALSE;
			session->paused = FALSE;
			session->mountpoint = NULL;
			/* Tell the core to tear down the PeerConnection, hangup_media will do the rest */				
			gateway->push_event(session->handle, &janus_streaming_plugin, NULL, event, NULL);
			gateway->close_pc(session->handle);
		}
		mp->listeners = g_list_remove_all(mp->listeners, session);
		viewer = g_list_first(mp->listeners);
	}

	json_decref(event);
	janus_mutex_unlock(&mp->mutex);
		
	if (mp) {
		teardown_pipeline(mp);

		JANUS_LOG(LOG_INFO, "Remove mountpoint %s\n", mp->id);
		if (!mp->destroyed) {
			JANUS_LOG(LOG_ERR, "Destroy %s\n", mp->id);
			mp->destroyed = janus_get_monotonic_time();
			g_hash_table_remove(mountpoints, mp->id);
		}
	}
	janus_mutex_unlock(&mountpoints_mutex);								
}

static void janus_streaming_destroy_mountpoint_if_not_used(janus_streaming_session *session)
{
	if (session->mountpoint) {			
		janus_mutex_lock(&session->mountpoint->mutex);

		guint old_listeners = g_list_length(session->mountpoint->listeners);			
		session->mountpoint->listeners = g_list_remove_all(session->mountpoint->listeners, session);			
		guint listeners = g_list_length(session->mountpoint->listeners);	
		JANUS_LOG(LOG_INFO, "Destroy the mountpoint %u  \n",listeners);		
		janus_mutex_unlock(&session->mountpoint->mutex);

		if (old_listeners && !listeners) {					
			teardown_pipeline(session->mountpoint);
			janus_mutex_lock(&mountpoints_mutex);
			JANUS_LOG(LOG_INFO, "Remove mountpoint - the last viewer  %s  \n",session->mountpoint->id);		
			janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, session->mountpoint->id);
			
			if (mp) {
				JANUS_LOG(LOG_INFO, "Remove mountpoint - the last viewer  %u  \n",listeners);
				if(!mp->destroyed) {
					JANUS_LOG(LOG_ERR, "Destroy %s\n", mp->id);
					mp->destroyed = janus_get_monotonic_time();
					g_hash_table_remove(mountpoints, mp->id);
				}
			}
			janus_mutex_unlock(&mountpoints_mutex);								
		}				
	}
}

void janus_streaming_destroy_session(janus_plugin_session *handle, int *error) {
	if (g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}	
	janus_streaming_session *session = (janus_streaming_session *)handle->plugin_handle; 
	if (!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		*error = -2;
		return;
	}
	JANUS_LOG(LOG_INFO, "Destroy streaming session...\n");

	if (session != NULL) {					
				
		session->stopping = TRUE;
		session->started = FALSE;
		session->paused = FALSE;

		janus_streaming_destroy_mountpoint_if_not_used(session);
	}
	 
	janus_mutex_lock(&sessions_mutex);	
	if(!session->destroyed) {
		session->destroyed = janus_get_monotonic_time();	
		g_hash_table_remove(sessions, handle);
		/* Cleaning up and removing the session is done in a lazy way */
		old_sessions = g_list_append(old_sessions, session);
	}
	janus_mutex_unlock(&sessions_mutex);
	JANUS_LOG(LOG_INFO, "\nPrint Sessions %u\n",handle);			
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_foreach (sessions, print_hash_value, NULL);
	janus_mutex_unlock(&sessions_mutex);

	return;
}

json_t *janus_streaming_query_session(janus_plugin_session *handle) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		return NULL;
	}	
	janus_streaming_session *session = (janus_streaming_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return NULL;
	}
	/* What is this user watching, if anything? */
	json_t *info = json_object();
	json_object_set_new(info, "state", json_string(session->mountpoint ? "watching" : "idle"));
	if(session->mountpoint) {
		json_object_set_new(info, "mountpoint_id", json_string(session->mountpoint->id));
		json_object_set_new(info, "mountpoint_name", session->mountpoint->name ? json_string(session->mountpoint->name) : NULL);
	}
	json_object_set_new(info, "destroyed", json_integer(session->destroyed));
	return info;
}

struct janus_plugin_result *janus_streaming_handle_message(janus_plugin_session *handle, char *transaction, json_t *message, json_t *jsep) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return janus_plugin_result_new(JANUS_PLUGIN_ERROR, g_atomic_int_get(&stopping) ? "Shutting down" : "Plugin not initialized", NULL);

	/* Pre-parse the message */
	int error_code = 0;
	char error_cause[512];
	json_t *root = message;
	json_t *response = NULL;

	if(message == NULL) {
		JANUS_LOG(LOG_ERR, "No message??\n");
		error_code = JANUS_STREAMING_ERROR_NO_MESSAGE;
		g_snprintf(error_cause, 512, "%s", "No message??");
		goto plugin_response;
	}

	janus_streaming_session *session = (janus_streaming_session *)handle->plugin_handle;	
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		error_code = JANUS_STREAMING_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "session associated with this handle...");
		goto plugin_response;
	}
	if(session->destroyed) {
		JANUS_LOG(LOG_ERR, "Session has already been destroyed...\n");
		error_code = JANUS_STREAMING_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "Session has already been destroyed...");
		goto plugin_response;
	}
	if(!json_is_object(root)) {
		JANUS_LOG(LOG_ERR, "JSON error: not an object\n");
		error_code = JANUS_STREAMING_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: not an object");
		goto plugin_response;
	}
	/* Get the request first */
	JANUS_VALIDATE_JSON_OBJECT(root, request_parameters,
		error_code, error_cause, TRUE,
		JANUS_STREAMING_ERROR_MISSING_ELEMENT, JANUS_STREAMING_ERROR_INVALID_ELEMENT);
	if(error_code != 0)
		goto plugin_response;
	json_t *request = json_object_get(root, "request");
	/* Some requests ('create' and 'destroy') can be handled synchronously */
	const char *request_text = json_string_value(request);
	if(!strcasecmp(request_text, "list")) {
		json_t *list = json_array();
		JANUS_LOG(LOG_VERB, "Request for the list of mountpoints\n");
		/* Return a list of all available mountpoints */
		janus_mutex_lock(&mountpoints_mutex);
		GHashTableIter iter;
		gpointer value;
		g_hash_table_iter_init(&iter, mountpoints);
		while (g_hash_table_iter_next(&iter, NULL, &value)) {
			janus_streaming_mountpoint *mp = value;
			if(mp->is_private) {
				/* Skip private stream */
				JANUS_LOG(LOG_VERB, "Skipping private mountpoint '%s'\n", mp->description);
				continue;
			}
			json_t *ml = json_object();
			json_object_set_new(ml, "id", json_string(mp->id));
			json_object_set_new(ml, "description", json_string(mp->description));	
			json_array_append_new(list, ml);
		}
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("list"));
		json_object_set_new(response, "list", list);
		goto plugin_response;
	} else if(!strcasecmp(request_text, "info")) {
		JANUS_LOG(LOG_VERB, "Request info on a specific mountpoint\n");
		/* Return info on a specific mountpoint */
		JANUS_VALIDATE_JSON_OBJECT(root, id_parameters,
			error_code, error_cause, TRUE,
			JANUS_STREAMING_ERROR_MISSING_ELEMENT, JANUS_STREAMING_ERROR_INVALID_ELEMENT);
		if(error_code != 0)
			goto plugin_response;
		json_t *id = json_object_get(root, "id");
		const gchar *id_value = json_string_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
			error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
			goto plugin_response;
		}
		json_t *ml = json_object();
		json_object_set_new(ml, "id", json_string(mp->id));
		json_object_set_new(ml, "description", json_string(mp->description));
		

		janus_mutex_unlock(&mountpoints_mutex);
		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("info"));
		json_object_set_new(response, "info", ml);
		goto plugin_response;
	} else if(!strcasecmp(request_text, "create")) {

		/* Create a new stream */
		JANUS_VALIDATE_JSON_OBJECT(root, create_parameters,
			error_code, error_cause, TRUE,
			JANUS_STREAMING_ERROR_MISSING_ELEMENT, JANUS_STREAMING_ERROR_INVALID_ELEMENT);
		if(error_code != 0)
			goto plugin_response;
		if(admin_key != NULL) {
			/* An admin key was specified: make sure it was provided, and that it's valid */
			JANUS_VALIDATE_JSON_OBJECT(root, adminkey_parameters,
				error_code, error_cause, TRUE,
				JANUS_STREAMING_ERROR_MISSING_ELEMENT, JANUS_STREAMING_ERROR_INVALID_ELEMENT);
			if(error_code != 0)
				goto plugin_response;
			JANUS_CHECK_SECRET(admin_key, root, "admin_key", error_code, error_cause,
				JANUS_STREAMING_ERROR_MISSING_ELEMENT, JANUS_STREAMING_ERROR_INVALID_ELEMENT, JANUS_STREAMING_ERROR_UNAUTHORIZED);
			if(error_code != 0)
				goto plugin_response;
		}
		json_t *type = json_object_get(root, "type");
		const char *type_text = json_string_value(type);
		json_t *secret = json_object_get(root, "secret");
		json_t *pin = json_object_get(root, "pin");
		json_t *permanent = json_object_get(root, "permanent");
		gboolean save = permanent ? json_is_true(permanent) : FALSE;
		if(save && config == NULL) {
			JANUS_LOG(LOG_ERR, "No configuration file, can't create permanent mountpoint\n");
			error_code = JANUS_STREAMING_ERROR_UNKNOWN_ERROR;
			g_snprintf(error_cause, 512, "No configuration file, can't create permanent mountpoint");
			goto plugin_response;
		}
		janus_streaming_mountpoint *mp = NULL;
		if(!strcasecmp(type_text, "rtp")) {

			json_t *id = json_object_get(root, "id");	
			json_t *name = json_object_get(root, "name");
			json_t *desc = json_object_get(root, "description");
			json_t *is_private = json_object_get(root, "is_private");

			if(id == NULL) {
				JANUS_LOG(LOG_VERB, "Missing id, will generate a random one...\n");
			} else {								
				janus_mutex_lock(&mountpoints_mutex);
				mp = g_hash_table_lookup(mountpoints, json_string_value(id));
				janus_mutex_unlock(&mountpoints_mutex);
				if(mp == NULL) {										
					mp = janus_streaming_create_rtp_source(
							handle,
							id ? json_string_value(id) : NULL,
							name ? (char *)json_string_value(name) : NULL,
							desc ? (char *)json_string_value(desc) : NULL);
					if(mp == NULL) {
						JANUS_LOG(LOG_ERR, "Error creating 'rtp' stream...\n");
						error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
						g_snprintf(error_cause, 512, "Error creating 'rtp' stream");
						goto plugin_response;
					}
					mp->is_private = is_private ? json_is_true(is_private) : FALSE;
				}	
				else
				{	
					JANUS_LOG(LOG_ERR, "Mountpoint exist '%s'...\n ", json_string_value(id));
					janus_streaming_message *msg = g_malloc0(sizeof(janus_streaming_message));
					msg->handle = handle;
					msg->message = json_pack("{ssss}", "request", "watch","id",json_string_value(id));						
					msg->transaction = NULL;
					msg->jsep = NULL;
					g_async_queue_push(messages, msg);						
				}		
			}	
		} else {
			JANUS_LOG(LOG_ERR, "Unknown stream type '%s'...\n", type_text);
			error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Unknown stream type '%s'...\n", type_text);
			goto plugin_response;
		}
		/* Any secret? */
		if(secret)
			mp->secret = g_strdup(json_string_value(secret));
		/* Any PIN? */
		if(pin)
			mp->pin = g_strdup(json_string_value(pin));
		if(save) {
			/* This mountpoint is permanent: save to the configuration file too
			 * FIXME: We should check if anything fails... */
			JANUS_LOG(LOG_VERB, "Saving mountpoint %s permanently in config file\n", mp->id);
			janus_mutex_lock(&config_mutex);
			char value[BUFSIZ];
			/* The category to add is the mountpoint name */
			janus_config_add_category(config, mp->name);
			/* Now for the common values */
			janus_config_add_item(config, mp->name, "type", type_text);
			g_snprintf(value, BUFSIZ, "%s", mp->id);
			janus_config_add_item(config, mp->name, "id", value);
			janus_config_add_item(config, mp->name, "description", mp->description);
			if(mp->is_private)
				janus_config_add_item(config, mp->name, "is_private", "yes");
			/* Some more common values */
			if(mp->secret)
				janus_config_add_item(config, mp->name, "secret", mp->secret);
			if(mp->pin)
				janus_config_add_item(config, mp->name, "pin", mp->pin);
			/* Save modified configuration */
			janus_config_save(config, config_folder, JANUS_STREAMING_PACKAGE);
			janus_mutex_unlock(&config_mutex);
		}
		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("created"));
		json_object_set_new(response, "created", json_string(mp->name));
		json_t *ml = json_object();
		json_object_set_new(ml, "id", json_string(mp->id));
		json_object_set_new(ml, "description", json_string(mp->description));		
		json_object_set_new(ml, "is_private", json_string(mp->is_private ? "true" : "false"));
		json_object_set_new(response, "stream", ml);
		goto plugin_response;
	} else if(!strcasecmp(request_text, "enable") || !strcasecmp(request_text, "disable")) {
		/* A request to enable/disable a mountpoint */
		JANUS_VALIDATE_JSON_OBJECT(root, id_parameters,
			error_code, error_cause, TRUE,
			JANUS_STREAMING_ERROR_MISSING_ELEMENT, JANUS_STREAMING_ERROR_INVALID_ELEMENT);
		if(error_code != 0)
			goto plugin_response;
		json_t *id = json_object_get(root, "id");
		const gchar *id_value = json_string_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
			error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
			goto plugin_response;
		}
		/* A secret may be required for this action */
		JANUS_CHECK_SECRET(mp->secret, root, "secret", error_code, error_cause,
			JANUS_STREAMING_ERROR_MISSING_ELEMENT, JANUS_STREAMING_ERROR_INVALID_ELEMENT, JANUS_STREAMING_ERROR_UNAUTHORIZED);
		if(error_code != 0) {
			janus_mutex_unlock(&mountpoints_mutex);
			goto plugin_response;
		}
		if(!strcasecmp(request_text, "enable")) {
			/* Enable a previously disabled mountpoint */
			JANUS_LOG(LOG_INFO, "[%s] Stream enabled\n", mp->name);
			mp->enabled = TRUE;
			/* FIXME: Should we notify the listeners, or is this up to the controller application? */
		} else {
			/* Disable a previously enabled mountpoint */
			JANUS_LOG(LOG_INFO, "[%s] Stream disabled\n", mp->name);
			mp->enabled = FALSE;

		}
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send a success response back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("ok"));
		goto plugin_response;
	} else if(!strcasecmp(request_text, "watch") || !strcasecmp(request_text, "start")
			|| !strcasecmp(request_text, "pause") || !strcasecmp(request_text, "stop")
			|| !strcasecmp(request_text, "switch")) {
		JANUS_LOG(LOG_VERB, "/* These messages are handled asynchronously */ \n");
		/* These messages are handled asynchronously */
		janus_streaming_message *msg = g_malloc0(sizeof(janus_streaming_message));
		msg->handle = handle;
		msg->transaction = transaction;
		msg->message = root;
		msg->jsep = jsep;

		g_async_queue_push(messages, msg);

		return janus_plugin_result_new(JANUS_PLUGIN_OK_WAIT, NULL, NULL);
	} else {
		JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
		error_code = JANUS_STREAMING_ERROR_INVALID_REQUEST;
		g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
	}

plugin_response:
		{
			if(error_code == 0 && !response) {
				error_code = JANUS_STREAMING_ERROR_UNKNOWN_ERROR;
				g_snprintf(error_cause, 512, "Invalid response");
			}
			if(error_code != 0) {
				/* Prepare JSON error event */
				json_t *event = json_object();
				json_object_set_new(event, "streaming", json_string("event"));
				json_object_set_new(event, "error_code", json_integer(error_code));
				json_object_set_new(event, "error", json_string(error_cause));
				response = event;
			}
			if(root != NULL)
				json_decref(root);
			if(jsep != NULL)
				json_decref(jsep);
			g_free(transaction);

			return janus_plugin_result_new(JANUS_PLUGIN_OK, NULL, response);
		}

}

void janus_streaming_setup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "WebRTC media is now available\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	janus_streaming_session *session = (janus_streaming_session *)handle->plugin_handle;	
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	g_atomic_int_set(&session->hangingup, 0);
	/* We only start streaming towards this user when we get this event */

	session->started = TRUE;
	/* Prepare JSON event */
	json_t *event = json_object();
	json_object_set_new(event, "streaming", json_string("event"));
	json_t *result = json_object();
	json_object_set_new(result, "status", json_string("started"));
	json_object_set_new(event, "result", result);
	int ret = gateway->push_event(handle, &janus_streaming_plugin, NULL, event, NULL);
	JANUS_LOG(LOG_VERB, "  >> Pushing event: %d (%s)\n", ret, janus_get_api_error(ret));
	json_decref(event);
}

void janus_streaming_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	/* FIXME We don't care about what the browser sends us, we're sendonly */
}

void janus_streaming_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len) {

	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;

	janus_streaming_session * session = (janus_streaming_session*)(handle->plugin_handle);

	if (!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}

	janus_streaming_mountpoint *mountpoint = (janus_streaming_mountpoint*)(session->mountpoint);

	if (!mountpoint) {
		JANUS_LOG(LOG_ERR, "No mountpoint associated with this session...\n");
		return;
	}

	int stream_type = video ? JANUS_STREAMING_STREAM_VIDEO : JANUS_STREAMING_STREAM_AUDIO;

	if (stream_type == JANUS_STREAMING_STREAM_VIDEO && janus_rtcp_has_pli(buf, len)) {

		GSocket * sock_rtcp_cli = mountpoint->socket[stream_type][JANUS_STREAMING_SOCKET_RTCP_RCV_CLI].socket;
		guint32 new_ssrc = mountpoint->ssrc[stream_type];

		//g_print("PLI sender_ssrc: %08X, receiver: %08X; to_fix: %08X\n", janus_rtcp_get_sender_ssrc(buf, len), janus_rtcp_get_receiver_ssrc(buf, len), new_ssrc);
		janus_rtcp_fix_ssrc(NULL, buf, len, 1, new_ssrc, new_ssrc);

		if (g_socket_send(sock_rtcp_cli, buf, len, NULL, NULL) < 0) {
			JANUS_LOG(LOG_ERR, "Send RTCP failed! type: %s\n", video ? "video" : "audio");
		}
	}

	/* We might interested in the available bandwidth that the user advertizes */
	uint64_t bw = janus_rtcp_get_remb(buf, len);
	if(bw > 0) {
		JANUS_LOG(LOG_HUGE, "REMB for this PeerConnection: %"SCNu64"\n", bw);
		/* TODO Use this somehow (e.g., notification towards application?) */
	}
	/* FIXME Maybe we should care about RTCP, but not now */
}


void janus_streaming_hangup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "Streaming: No WebRTC media anymore\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	janus_streaming_session *session = (janus_streaming_session *)handle->plugin_handle;	
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	if(g_atomic_int_add(&session->hangingup, 1))
		return;

	/* FIXME Simulate a "stop" coming from the browser */
	janus_streaming_message *msg = g_malloc0(sizeof(janus_streaming_message));
	msg->handle = handle;
	msg->message = json_pack("{ss}", "request", "stop");
	msg->transaction = NULL;
	msg->jsep = NULL;
	g_async_queue_push(messages, msg);
}

/* Thread to handle incoming messages */
static void *janus_streaming_handler(void *data) {
	JANUS_LOG(LOG_VERB, "Joining Streaming handler thread\n");
	janus_streaming_message *msg = NULL;
	int error_code = 0;
	char error_cause[512];
	json_t *root = NULL;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		msg = g_async_queue_pop(messages);
		if(msg == NULL)
			continue;
		if(msg == &exit_message)
			break;
		if(msg->handle == NULL) {
			janus_streaming_message_free(msg);
			continue;
		}
		janus_streaming_session *session = NULL;
		janus_mutex_lock(&sessions_mutex);
		if(g_hash_table_lookup(sessions, msg->handle) != NULL ) {
			session = (janus_streaming_session *)msg->handle->plugin_handle;
		}
		janus_mutex_unlock(&sessions_mutex);
		if(!session) {
			JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
			janus_streaming_message_free(msg);
			continue;
		}
		if(session->destroyed) {
			janus_streaming_message_free(msg);
			continue;
		}
		/* Handle request */
		error_code = 0;
		root = NULL;
		if(msg->message == NULL) {
			JANUS_LOG(LOG_ERR, "No message??\n");
			error_code = JANUS_STREAMING_ERROR_NO_MESSAGE;
			g_snprintf(error_cause, 512, "%s", "No message??");
			goto error;
		}
		root = msg->message;
		/* Get the request first */
		JANUS_VALIDATE_JSON_OBJECT(root, request_parameters,
			error_code, error_cause, TRUE,
			JANUS_STREAMING_ERROR_MISSING_ELEMENT, JANUS_STREAMING_ERROR_INVALID_ELEMENT);
		if(error_code != 0)
			goto error;
		json_t *request = json_object_get(root, "request");
		const char *request_text = json_string_value(request);
		json_t *result = NULL;
		const char *sdp_type = NULL;
		char *sdp = NULL;
		/* All these requests can only be handled asynchronously */
		if(!strcasecmp(request_text, "watch")) {			
			JANUS_VALIDATE_JSON_OBJECT(root, id_parameters,
				error_code, error_cause, TRUE,
				JANUS_STREAMING_ERROR_MISSING_ELEMENT, JANUS_STREAMING_ERROR_INVALID_ELEMENT);
			if(error_code != 0)
				goto error;
			json_t *id = json_object_get(root, "id");
			const gchar *id_value = json_string_value(id);			
			janus_mutex_lock(&mountpoints_mutex);			
			janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
			if(mp == NULL) {
				JANUS_LOG(LOG_ERR, "No such mountpoint/stream %s\n", id_value);
			}

			// A secret may be required for this action 
			JANUS_CHECK_SECRET(mp->pin, root, "pin", error_code, error_cause,
				JANUS_STREAMING_ERROR_MISSING_ELEMENT, JANUS_STREAMING_ERROR_INVALID_ELEMENT, JANUS_STREAMING_ERROR_UNAUTHORIZED);
			if(error_code != 0) {
				janus_mutex_unlock(&mountpoints_mutex);
				goto error;
			}

			janus_mutex_unlock(&mountpoints_mutex);
			
			JANUS_LOG(LOG_VERB, "Request to watch mountpoint/stream %s\n", id_value);
			session->stopping = FALSE;
			session->mountpoint = mp;
	
			/* TODO Check if user is already watching a stream, if the video is active, etc. */
			janus_mutex_lock(&mp->mutex);
			mp->listeners = g_list_append(mp->listeners, session);
			janus_mutex_unlock(&mp->mutex);			
		
			sdp_type = "offer";	/* We're always going to do the offer ourselves, never answer */
			char sdptemp[2048];
			memset(sdptemp, 0, 2048);
			gchar buffer[512];
			memset(buffer, 0, 512);
			gint64 sessid = janus_get_real_time();
			gint64 version = sessid;	/* FIXME This needs to be increased when it changes, so time should be ok */
			g_snprintf(buffer, 512,
				"v=0\r\no=%s %"SCNu64" %"SCNu64" IN IP4 127.0.0.1\r\n",
					"-", sessid, version);
			g_strlcat(sdptemp, buffer, 2048);
			g_strlcat(sdptemp, "s=Streaming Test\r\nt=0 0\r\n", 2048);
			
			//todo: move to new function
			/* Add audio line */
			g_snprintf(buffer, 512,
				"m=audio 1 RTP/SAVPF %d\r\n"
				"c=IN IP4 1.1.1.1\r\n",
				mp->codecs.audio_pt);
			g_strlcat(sdptemp, buffer, 2048);

			g_snprintf(buffer, 512,
				"a=rtpmap:%s/2\r\n",
				 mp->codecs.audio_rtpmap);
			g_strlcat(sdptemp, buffer, 2048);

			
			g_snprintf(buffer, 512,
				"a=fmtp:%d %s\r\n",
				mp->codecs.audio_pt, "");
			g_strlcat(sdptemp, buffer, 2048);

			g_strlcat(sdptemp, "a=sendonly\r\n", 2048);

			/* Add video line */
			g_snprintf(buffer, 512,
				"m=video 1 RTP/SAVPF %d\r\n"
				"c=IN IP4 1.1.1.1\r\n",
				mp->codecs.video_pt);
			g_strlcat(sdptemp, buffer, 2048);
			
			g_snprintf(buffer, 512,
				"a=rtpmap:%s\r\n",
				 mp->codecs.video_rtpmap);
			g_strlcat(sdptemp, buffer, 2048);


			g_snprintf(buffer, 512,
				"a=fmtp:%d %s\r\n",
				mp->codecs.video_pt, "");
			g_strlcat(sdptemp, buffer, 2048);

			g_snprintf(buffer, 512,
				"a=rtcp-fb:%d nack\r\n",
				mp->codecs.video_pt);
			g_strlcat(sdptemp, buffer, 2048);

			g_snprintf(buffer, 512,
				"a=rtcp-fb:%d nack pli\r\n",
				mp->codecs.video_pt);
			g_strlcat(sdptemp, buffer, 2048);

			g_snprintf(buffer, 512,
				"a=rtcp-fb:%d goog-remb\r\n",
				mp->codecs.video_pt);
			g_strlcat(sdptemp, buffer, 2048);

			g_strlcat(sdptemp, "a=sendonly\r\n", 2048);

			sdp = g_strdup(sdptemp);	
			
			JANUS_LOG(LOG_VERB, "Going to offer this SDP:\n%s\n", sdp);
			result = json_object();
			json_object_set_new(result, "status", json_string("preparing"));
		} else if(!strcasecmp(request_text, "start")) {			
			if(session->mountpoint == NULL) {
				JANUS_LOG(LOG_VERB, "Can't start: no mountpoint set\n");
				error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't start: no mountpoint set");
				goto error;
			}
			JANUS_LOG(LOG_VERB, "Starting the streaming\n");
			session->paused = FALSE;
			result = json_object();
			/* We wait for the setup_media event to start: on the other hand, it may have already arrived */
			json_object_set_new(result, "status", json_string(session->started ? "started" : "starting"));
		} else if(!strcasecmp(request_text, "pause")) {			
			if(session->mountpoint == NULL) {
				JANUS_LOG(LOG_VERB, "Can't pause: no mountpoint set\n");
				error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't start: no mountpoint set");
				goto error;
			}
			JANUS_LOG(LOG_VERB, "Pausing the streaming\n");
			session->paused = TRUE;
			result = json_object();
			json_object_set_new(result, "status", json_string("pausing"));
		} else if(!strcasecmp(request_text, "destroy")) {
			JANUS_LOG(LOG_INFO, "Streaming: destroying the mountpoint\n");
			janus_streaming_destroy_mountpoint(session->mountpoint->id);
		} 
		else {
			JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
			error_code = JANUS_STREAMING_ERROR_INVALID_REQUEST;
			g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
			goto error;
		}
		
		/* Any SDP to handle? */
		const char *msg_sdp_type = json_string_value(json_object_get(msg->jsep, "type"));
		const char *msg_sdp = json_string_value(json_object_get(msg->jsep, "sdp"));
		if(msg_sdp) {
			JANUS_LOG(LOG_VERB, "This is involving a negotiation (%s) as well (but we really don't care):\n%s\n", msg_sdp_type, msg_sdp);
		}

		/* Prepare JSON event */
		
		json_t *jsep = json_pack("{ssss}", "type", sdp_type, "sdp", sdp);
		json_t *event = json_object();
		json_object_set_new(event, "streaming", json_string("event"));

		//JANUS_LOG(LOG_INFO,"\n Prepare JSON event \n %s \n ",sdp);
		if(result != NULL)
			json_object_set_new(event, "result", result);
		int ret = gateway->push_event(msg->handle, &janus_streaming_plugin, msg->transaction, event, jsep);
		JANUS_LOG(LOG_VERB, "  >> Pushing event: %d (%s)\n", ret, janus_get_api_error(ret));
		g_free(sdp);
		json_decref(event);
		json_decref(jsep);
		janus_streaming_message_free(msg);
		continue;
		
error:
		{
			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "streaming", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			int ret = gateway->push_event(msg->handle, &janus_streaming_plugin, msg->transaction, event, NULL);
			JANUS_LOG(LOG_VERB, "  >> Pushing event: %d (%s)\n", ret, janus_get_api_error(ret));
			json_decref(event);
			janus_streaming_message_free(msg);
		}
	}
	JANUS_LOG(LOG_VERB, "Leaving Streaming handler thread\n");
	return NULL;
}

static void janus_streaming_mountpoint_free(gpointer data) {
	JANUS_LOG(LOG_VERB, "janus_streaming_mountpoint_free\n");

	janus_streaming_mountpoint *mp = (janus_streaming_mountpoint*)data;

	if (mp) {
		g_free(mp->id);
		g_free(mp->name);
		g_free(mp->description);
		g_free(mp->secret);
		g_free(mp->pin);
		g_free(mp->codecs.audio_rtpmap);
		g_free(mp->codecs.audio_fmtp);
		g_free(mp->codecs.video_rtpmap);
		g_free(mp->codecs.video_fmtp);
		g_free(mp);
	}
}

/* Helper to create an RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
janus_streaming_mountpoint *janus_streaming_create_rtp_source(
		janus_plugin_session *handle,
		const gchar *id, char *name, char *desc)
{
	janus_mutex_lock(&mountpoints_mutex);

	if(id == NULL) {
		JANUS_LOG(LOG_VERB, "Missing id, will generate a random one...\n");
		while(id == NULL) {
			id = random_id();
			if(g_hash_table_lookup(mountpoints, id) != NULL) {
				/* ID already in use, try another one */
				id = NULL;
			}
		}
	} else {
		id = g_strdup(id);
	}

	janus_mutex_unlock(&mountpoints_mutex);

	char tempname[255];
	if(name == NULL) {
		JANUS_LOG(LOG_VERB, "Missing name, will generate a random one...\n");
		memset(tempname, 0, 255);
		g_snprintf(tempname, 255, "%s", id);
	}

	
	/* Create the mountpoint */
	janus_streaming_mountpoint *live_rtp = g_malloc0(sizeof(janus_streaming_mountpoint));
	live_rtp->id = (gchar *)id;
	live_rtp->name = g_strdup(name ? name : tempname);
	char *description = NULL;
	if(desc != NULL)
		description = g_strdup(desc);
	else
		description = g_strdup(name ? name : tempname);
	live_rtp->description = description;
	live_rtp->enabled = TRUE;
	live_rtp->active = FALSE;
	live_rtp->listeners = NULL;
	live_rtp->destroyed = 0;
	gchar *source = NULL;

	janus_mutex_lock(&mountpoints_mutex);
	if (!registry_endpoint) {
			JANUS_LOG(LOG_WARN, "Registry endpoint not specified. Trying local registry.\n");			
			
		}
		else {			
			source = get_source_from_registry_by_id(registry_endpoint, id);
			JANUS_LOG(LOG_INFO,"\n*** setup_pipeline   source from registry %s ***\n",source);
			if(source){
				janus_mutex_init(&live_rtp->mutex);
				g_hash_table_insert(mountpoints, live_rtp->id, live_rtp);				
				setup_pipeline(handle, source, live_rtp->id);		
			}
		}		

	if((gchar*)source){
	  g_free(source);
	  source = NULL;
	}

	janus_mutex_unlock(&mountpoints_mutex);

	return live_rtp;
}

static void janus_streaming_relay_rtp_packet(gpointer data, gpointer user_data) {

	janus_streaming_rtp_relay_packet *packet = (janus_streaming_rtp_relay_packet *)user_data;
	if(!packet || !packet->data || packet->length < 1) {
		JANUS_LOG(LOG_ERR, "Invalid packet...\n");
		return;
	}
	janus_streaming_session *session = (janus_streaming_session *)data;
	if(!session || !session->handle) {
		JANUS_LOG(LOG_ERR, "Invalid session...\n");
		return;
	}
	if((!session->started || session->paused )) {
		JANUS_LOG(LOG_VERB, "Streaming not started yet for this session...\n");
		return;
	}
	else{
		gateway->relay_rtp(session->handle, packet->is_video, (char *)packet->data, packet->length);
	}
	return;
}

gboolean janus_streaming_send_rtp_src_received(GSocket *socket, GIOCondition condition, janus_streaming_socket_cbk_data * data)
{
	char buf[1500];
	gssize len;

	janus_streaming_mountpoint * mountpoint = (janus_streaming_mountpoint*)data->session;

	if (!mountpoint) {
		JANUS_LOG(LOG_ERR, "janus_streaming_send_rtp_src_received: mountpoint is NULL\n");
		return TRUE;
	}

	if (g_atomic_int_get(&stopping) || mountpoint->destroyed) {
		return TRUE;
	}

	len = g_socket_receive(socket, (gchar*)buf, sizeof(buf), NULL, NULL);

	if (len > 0) {
		JANUS_LOG(LOG_HUGE, "%s RTP sent; len=%ld\n", data->is_video ? "Video" : "Audio", len);
	    janus_streaming_rtp_relay_packet packet;
		rtp_header *rtp = (rtp_header *)buf;

		packet.data = rtp;
		packet.length = len;
		packet.is_video = data->is_video;

		packet.timestamp = ntohl(packet.data->timestamp);
		packet.seq_number = ntohs(packet.data->seq_number);

		mountpoint->ssrc[JANUS_STREAMING_STREAM_VIDEO] = ntohl(packet.data->ssrc);
		if(mountpoint->active == FALSE)
			mountpoint->active = TRUE;

		janus_mutex_lock(&mountpoint->mutex);
		g_list_foreach(mountpoint->listeners, janus_streaming_relay_rtp_packet, &packet);
		janus_mutex_unlock(&mountpoint->mutex);
	}

	return TRUE;
}


static void janus_streaming_parse_ports_range(janus_config_item *ports_range, uint16_t *min_port, uint16_t * max_port)
{
	if (ports_range && ports_range->value)
	{
		/* Split in min and max port */
		char *maxport = strrchr(ports_range->value, '-');
		if (maxport != NULL)
		{
			*maxport = '\0';
			maxport++;
			*min_port = atoi(ports_range->value);
			*max_port = atoi(maxport);
			maxport--;
			*maxport = '-';
		}
		if (*min_port > *max_port)
		{
			int temp_port = *min_port;
			*min_port = *max_port;
			*max_port = temp_port;
		}
		if (*max_port == 0)
			*max_port = 65535;
		JANUS_LOG(LOG_VERB, "UDP port range: %u - %u\n", *min_port, *max_port);
	}
}

//todo: change as in source
static gboolean janus_streaming_create_sockets(socket_utils_socket socket[JANUS_STREAMING_STREAM_MAX][JANUS_STREAMING_SOCKET_MAX]) {
	
	gboolean result = TRUE;

	for (int i = 0; i < JANUS_STREAMING_STREAM_MAX; i++)
	{
		if (!socket_utils_create_server_socket(&socket[i][JANUS_STREAMING_SOCKET_RTP_SRV])) {
			result = FALSE;
		}

		if (!socket_utils_create_server_socket(&socket[i][JANUS_STREAMING_SOCKET_RTCP_RCV_SRV])) {
			result = FALSE;
		}

		if (!socket_utils_create_client_socket(&socket[i][JANUS_STREAMING_SOCKET_RTCP_RCV_CLI], socket[i][JANUS_STREAMING_SOCKET_RTCP_RCV_SRV].port)) {
			result = FALSE;
		}
	
		if (!socket_utils_create_server_socket(&socket[i][JANUS_STREAMING_SOCKET_RTCP_SND_SRV])) {
			result = FALSE;
		}

	}
	
	return result;
}

void janus_streaming_send_watch_request(gchar * id, gpointer handle) {
	janus_streaming_message *msg = g_malloc0(sizeof(janus_streaming_message));
	msg->handle = handle;
	msg->message = json_pack("{ssss}", "request", "watch","id", id);	 
	msg->transaction = NULL;
	msg->jsep = NULL;
	g_async_queue_push(messages, msg);
}

void janus_streaming_send_destroy_request(gchar * id, gpointer handle) {

	JANUS_LOG(LOG_INFO, "janus_streaming_send_destroy_request\n");

	janus_streaming_message *msg = g_malloc0(sizeof(janus_streaming_message));
	msg->handle = handle;
	msg->message = json_pack("{ss}", "request", "destroy");
	msg->transaction = NULL;
	msg->jsep = NULL;
	g_async_queue_push(messages, msg);
}
